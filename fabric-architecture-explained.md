# Hyperledger Fabric 架构说明

Hyperledger Fabric 带来了以下优势：

* **链码信任灵活性：** 架构将对链码（区块链应用程序）的信任假设与对排序的信任假设分离。换种说法，排序服务可以由一组节点（排序者）提供，并容忍其中一部分失败或作弊，每个链码可以有不同的背书者。
* **可扩展性：** 由于负责特定链码的背书者与排序者不重复，系统可以比由相同节点完成背书和排序这两个功能更加容易扩展。特别的，当不同的链码指定不同的背书者时，使不同背书者之间的链码分离，并且允许并行执行链码。此外，执行链码的资源消耗可能很大，于是让其与关键的排序服务分开单独部署。
* **保密性：** 架构使得对交易的内容和状态更新有保密要求的链码部署更加容易。
* **共识模块化：** 架构是模块化的，并且允许可插拔的实现共识机制（比如排序服务）。

---

**第一部分：Hyperledger Fabric v1 系统架构元素**

1. 系统架构
2. 交易背书的基本工作流
3. 背书策略

**第二部分：v1 后的架构元素**

4. 账本检查点（修订中）

## 1. 系统架构

区块链是一个由许多节点互相通信组成的分布式系统。区块链运行的程序叫做链码，用来保存状态和账本数据、执行交易。因为交易是在链码上调用的操作，因而链码是区块链结构的主要元素。交易必须被“背书”，而且只有背书过的交易才可以被提交或者是改变状态。有一个或多个用于管理功能和参数的特殊的链码，统称为系统链码。

### 1.1 交易

交易有两种类型：

* **部署交易（Deploy transactions）：** 创建新链码并以一个程序作为参数。当一个部署链码执行成功以后，链码就被安装在区块链上。
* **调用交易（Invoke transactions）：** 在之前部署的链码的上下文中执行操作。一笔调用交易指的是一个链码和他提供的若干功能中的其中一个。如果调用交易成功，链码执行了特定的函数，这个函数可能涉及修改相应的状态，然后返回结果。

后面会讲到，部署交易是一种特殊的调用交易，部署交易创建新的链码，相当于系统链码上的调用交易。

备注：本文档假定一笔交易或者创建新链码，或者调已经部署的链码提供的操作。本文档不包括：a) 查询（只读）交易的优化（已包含在 v1 版本），b) 跨链码交易的支持（v1 后版本特性）

### 1.2 区块链数据结构

#### 1.2.1 状态（status）

在建模中，区块链的最新状态为一个有版本的键值存储（KVS），名字作为键，值是任意二进制大对象（blobs）。这些键值对被运行在区块链上的链码（应用程序）通过`put`和`get`的 KVS 操作来操纵。状态被持久化存储并且状态的更新被记录为日志。请注意状态模型采用的是版本化的 KVS，具体实现可以使用 KVS 存储，也可以用关系数据库系统或其他的解决方案。

更正式地说，状态`s`被建模为一个映射的元素 `K -> (V X N)`，其中：

* `K`是键集合
* `V`是值集合
* `N`是一个版本号的无穷有序集合。内射函数`next: N -> N`取`N`中的一个元素并返回下一个版本号

`V`和`N`都包含一个特别的元素⊥（空类型），是`N`的最小元素。初始情况下所有的键都映射为(⊥, ⊥)，对于`s(k)=(v,ver)`我们通过`s(k).value`表示`v`，用`s(k).version`表示`ver`。

KVS 操作原型如下：

* `put(k,v)` for `k` ∈ `K` and `v` ∈ `V`, 状态`s`的新状态`s'`计算方法是：`s'(k)=(v,next(s(k).version))`。并且对所有的`k'!=k`，表达式`s'(k')=s(k')`都成立。
* `get(k)`返回`s(k)`

状态由对等节点维护，而不是 order 节点和客户端。

**状态分区（State partitioning）：** KVS 中的键可以通过名称就能识别出它们属于哪个链码，所以只有特定链码的交易才能修改属于这个链码的键。原则上，任意的链码都能读取属于其他链码的键（机密链码的状态是不能明文读取的，参考第6部分）。修改两个或者多个链码状态的跨链交易，v1 的后续版本会支持。

#### 1.2.2 账本（ledger）

账本提供一份可验证历史信息，记录所有在系统操作中发生的成功的状态改变（有效交易）和未成功的对改变状态的尝试（无效交易）。

账本由排序服务构建为一个完整排序的交易（有效的和无效的）区块的哈希链。哈希链强制要求账本中的区块是完全排序的，并且每个区块内包含的交易是完全排序的。

账本存储在所有的对等节点里，也可以选择保存在一部分排序者里。存在排序者节点内的账本我们叫排序者的账本（OedererLedger），而存在对等节点的账本我们叫对等节点账本（PeerLedger）。对等节点账本与排序者账本不同之处在于对等节点账本本地维护一个位掩码来区分有效交易和无效交易。

对等节点可以删除对等节点账本（v1 后续功能）。排序者维护排序者账本用于容错和（对等节点账本的）可用性并可以随时决定删除对等节点账本，前提是排序服务的属性保持不变。

账本允许对等节点重播所有交易的历史来重构状态。因此，1.2.1 节谈到的状态是一个可选的数据结构。

### 1.3 节点（Node）

节点是区块链的通信实体。节点是一个逻辑的概念，不同类型的节点是可以运行在同一个物理服务器上的。重要的是节点是怎么被分组成“信任域（trust domains）”，怎么和控制它们的逻辑实体相关联。

有三种类型的节点：

* **客户端（client）或提交客户端（submitting-client）：** 一个客户端向背书者提交一笔实际发生的交易调用，并将交易提案广播给排序服务。
* **对等节点（peer）：** 确认交易和维护账本的状态、保存账本的副本。除此之外，对等节点有一个特别的背书者角色。
* **排序服务节点（Ordering-service-node ）或者排序者（orderer）：** 运行保证送达（deliver）的通信服务，如原子广播或完全排序广播。

接下来详细介绍各个节点类型。

#### 1.3.1 客户端（client）

一个客户端是一个代表最终用户的实体。它必须与一个对等节点连接以实现同区块链的通信。客户端自己选择连接到任意的对等节点。客户端创建然后调用交易。

客户端与对等节点和排序服务都通信。

#### 1.3.2 对等节点（peer）

一个对等节点从排序服务接收以区块形式更新的有序状态，并且维护状态和账本。

对等节点可以额外承担一个特殊的背书节点（endorsing peer）的角色，或者称为背书者（endorser）。背书节点的特殊功能发生在特定的链码上，在一笔交易确认前为这笔交易背书。每一个链码可以指定一个关联一组背书节点的背书策略。这个策略定义了一个有效交易背书的充要条件（一般是一组背书者的签名）。对于安装新链码来部署交易的情况，（部署）背书策略被指定为系统链码的背书策略。

#### 1.3.3 排序服务节点（Orderers）

排序者构建排序服务，即一个提供保证送达（deliver）的通信结构。排序服务可以由不同的方法实现：可以是一个中心化的服务排序（例如在部署和测试时），也可以是针对不同的网络和节点故障模型的分布式协议。

排序服务为客户端和对等节点提供了一个共享的通信通道和一个交易信息的广播服务。客户端连接到通道（channel）上，然后可以在通道内向全部对等节点传送（deliver）广播信息。通道支持全部信息的原子传递，即消息通信是可靠（针对特定实现方法）的
完全排序（total-order）的。换种说法，通道输出相同的信息到所有连通的对等节点，并且是按照相同的逻辑顺序输出。这个原子通信保证也称为完全顺序广播（total-order broadcast）、原子广播，或分布式系统上下文中的共识。发送的消息是将要包含在区块链状态中的候选交易。

**分区（ordering service channels）：** 排序服务可以支持多通道，这个通道就类似于发布/订阅消息系统里的主题（topic）。客户端可以连接到一个给定的通道发送消息和接收消息。通道可以被理解为分区，因为连接到一个通道的客户端不知道其他通道的存在，不过客户端可以连接到多个通道。即便Hyperledger Fabric 的一些排序服务支持多通道，为了简化表达，后续阐述将假定排序服务由一个单通道组成。

**排序服务API：** 对等节点通过排序服务提供的接口连接到排序服务提供的通道上，排序服务API由两个基本操作组成（通常为异步事件）：

 * **broadcast(blob)**：广播，客户端调用这个操作在通道内广播任意信息`blob`。在拜占庭容错问题中向一个服务发送一个请求的时候也被称为`request(blob)`。
 * **deliver(seqno, prevhash, blob)**：传递，排序服务在对等节点调用这个操作传递包含指定的非负整数序列号（seqno）和前一个传递的 blob（prevhash）的哈希值的信息blob。换种说法，它是排序服务的一个输出事件。`deliver()`在发布-订阅系统中有时也被称为`notify()`，在拜占庭容错系统中被称为`commit()`。

**账本和区块编队：** 账本包括排序服务输出的全部数据。简言之，它是一个`deliver(seqno, prevhash, blob)`的序列，依据的是计算前面提到的`prevhash`来构建一条哈希链。

大多数时候，为了提高效率，排序服务会将交易`（blob）`打包，在一个`deliver`事件中输出多个区块，而不是每一笔交易单独输出。在这种情况下，排序服务必须对每一个区块里的交易强加一个确定的顺序。一个区块里的交易数量可以由一个排序服务的具体实现动态选择。

接下来，为了表达简便，我们基于每次`deliver`一个`blob`的假设定义了排序服务属性并且解释了交易背书的工作流。这个概念可以轻松扩展到区块，基于上面说的一个`block`里面的`blob`有确定的顺序，我们假定一个`block`的`deliver`事件对应一个`block`里的每一个`blob`的一系列`deliver`事件。

**排序服务属性**

排序服务（或原子广播通道）的保证规定了广播消息会发生什么和完成传递的消息之间存在什么关系。这些保证如下：

1. **安全性（一致性保证）：** 只要对等节点连接上通道足够长的时间（他们可以断开连接或者宕机，但是会重启和重连），他们会看到唯一一串完成传递的`(seqno, prevhash, blob)`的信息。这意味着输出（`deliver()`事件）在所有对等节点以相同的顺序发生，并且输出（`output`）依据序号为同一个序号携带相同的内容（`blob`和`prehash`）。注意这仅仅是一个逻辑顺序，而且一个对等节点上的`delever(seqno, prevhash, blob)`不要求与在其他对等节点上输出相同消息的`delever(seqno, prevhash, blob)`实时发生。换句话说，给定一个特定的`seqno`，没有两个对等节点传递不同的`prevhash`或`blob`值。此外，除非某个客户端（对等节点）实际调用了`broadcast(blob)`，没有`blob`值会被传送，每个广播过的`blob`只传递一次。此外，`deliver()`事件包含了前一个`deliver()`事件的加密哈希值（`prevhash`）。当排序服务实施原子广播保证时，`prevhash`是序列号为`seqno-1`的`deliver()`事件的哈希值。这就在不同的`deliver()`事件之间建立了一个哈希链，用于校验排序服务输出的正确性。第一个`deliver()`事件是一个特殊情况，`prevhash`有一个默认值。
2. **活跃度（Liveness）：传递保证（delivery guarantee）** 排序服务的活跃度保证是排序服务的实现指定的。精确的保证要依赖网络和节点故障模型。

总的来说，排序服务保证如下属性：

* **一致（Agreement）：** 正常对等节点的任意两个事件，`deliver(seqno, prevhash0, blob0)`和`deliver(seqno, prevhash1, blob1)`，如果有相同的`seqno`，则有`prevhash0==prevhash1`，`blob0==blob1`；
* **哈希链的完整性（Hashchain integrity）：** 正常对等节点的任意两个事件：`deliver(seqno-1, prevhash0, blob0)`和`deliver(seqno, prevhash, blob)`, `prevhash = HASH(seqno-1||prevhash0||blob0)`;
* **不跳跃（No skipping）：** 如果一个排序服务给一个正常节点`p`输出`deliver(seqno, prevhash, blob)`，如果`seqno>0`，则`p`一定已经传递了`deliver(seqno-1, prevhash0, blob0)`事件；
* **不创建（No creation）：** 一个正常节点的任意`deliver(seqno, prevhash, blob)`事件，前面一定有一个对等节点发送了`broadcast(blob)`事件；
* **不重复（No duplication，可选的）：** 对任意的两个事件`broadcast(blob)`和`broadcast(blob')`，当正常对等节点交付了两个事件，`deliver(seqno0, prevhash0, blob)`和`deliver(seqno1, prevhash1, blob')`，如果`blob==blob'`，则有`seqno0==seqno1`和`prevhash0==prevhash1`成立；
* **活跃度（Liveness）:** 如果一个正常对等节点产生了`broadcast(blob)`事件，则每个正常对等节点“最终”都会发出一个`deliver(*, *, blob)`事件，其中`*`代表任意值。

## 2. 交易背书的基本流程（Basic workflow of transaction endorsement）

下面我们概要性的介绍一个交易的高层请求流程。

备注：注意后面的协议并不假定所有的交易都是确定性的，允许不确定性的交易。

### 2.1 客户端创建一个交易并发送给自己选择的一个背书节点

客户端向它选定的一组背书节点发送一个`PROPOSE`消息（可能不是同时发送）来调用一笔交易。这一组给定`chaincodeID`的背书节点通过对等节点对客户端提供服务，对等节点通过背书策略认同一组背书节点。举个例子，交易可以被发送到给定`chaincodeID`的所有背书者。也就是说，某些背书者可以是离线的，其他背书者可以拒绝为这笔交易背书。提交的客户端尝试满足所有可用背书者的策略要求。

接下来，我们先详细介绍`PROPOSE`信息的格式，然后讨论客户端和背书者之间可能的交互模式。

#### 2.1.1 PROPOSE 信息格式

`PROPOSE`信息的格式是`<PROPOSE,tx,[anchor]>`，`tx`是一个强制参数，而`anchor`是可选的，以下会说明：

* 对于`tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>`
  * **clientID** 为提交客户端的 ID
  * **chaincodeID** 为引用交易相关的链码
  * **txPayload** 为提交交易自身的载体
  * **timestamp** 是由客户端维护的一个单独递增（为每一笔交易）整型值
  * **clientSig** 是`tx`的其它域客户端签名

`txPayload`的细节会在调用交易和部署交易之间有所不同（即，调用交易引用部署指定的系统链码）。对于调用交易，`txPayload`会包含两个域

* 
  * `txPayload = <operation, metadata>`，其中
    * **operation** 表示链码操作（函数）和参数
    * **metadata** 表示调用相关的属性

对于部署交易，`txPayload`会包含三个域

*  
  * `txPayload = <source, metadata, policies>`，其中
    * **source** 表示链码的源码
    * **metadata** 表示链码和应用的相关属性
    * **policies** 包含所有peer节点可访问的链码的相关策略，比如背书策略。注意背书策略在部署交易中不支持`txPayload`，但部署的`txPayload`包含背书策略ID和它的参数。

* **anchor**包含读版本依赖，或更具体地说，键-版本（key-version）对（即，`anchor`是`KxN`的一个子集），它捆绑或“锚”`PROPOSE`请求到指定`KVS`中`key`的版本。如果客户端指定`anchor`参数，背书者背书交易的情况是，只基于读它本地`KVS`匹配`anchor`中的相应`KEY`的版本号。

`tx`加密哈希被所有`node`节点用作唯一的交易标识`tid`（即，`tid=HASH(tx)`）。客户端保存`tid`在内存中，等待背书 peer 节点的响应。

#### 2.1.2 消息模式（Message patterns）

客户端决定与背书者互动的顺序。例如，客户端通常会发送（即，没有`anchor`参数）到一个单独的背书者，背书者随后产生版本依赖（`anchor`）,客户端可以在晚些时候使用这个版本依赖（`anchor`）作为它的`PROPOSE`消息参数，发送给其它背书者。另外的例子，客户端能直接发送（没有`anchor`）到它选择的所有背书者。不同的通信模式都有可能，客户端在这方面是自由的。

### 2.2 背书 peer 节点模拟交易和产生背书签名

在从客户端接收消息时，背书 peer 节点`epID`首先校验客户端签名`clientSig`，然后模拟一个交易。如果客户端指定了`anchor`，那么背书 peer 节点模拟交易只基于在它本地`KVS`匹配的由`anchor`指定的版本号对应的`key`读版本号（即，下面定义的`readset`）。

模拟一个交易涉及背书节点尝试执行一个交易（`txPayload`）, 通过调用链码到交易引用（`chaincodeID`）和背书 peer 节点本地持有的状态拷贝。

作为执行的结果，背书 peer 节点计算读版本依赖（`readset`）和状态更新（`writeset`），也在`DB`语言中称为`MVCC+postimage info`。

回顾状态包含键/值对。所有键/值对实体都是版本化的，那就是说，每个实体包含排序版本信息，它是在每次键的值更新时增加的。解释交易的 peer 节点记录了所有的被链码访问的键/值对，不管读或是写，peer 节点不会更新它的状态。更具体地说：

* 在背书节点执行一个交易前给定状态`s`，被交易读取的每个键`k`，键/值对`(k,s(k).version)`被添加到`readset`。
* 此外，对于每一个被交易编辑的键`k`到值`v’`，键/值对`(k,v’)`被添加到`writeset`。或者，`v’`能成为新值与前值`(s(k).value)`的增量。

如果客户端在`PROPOSE`消息中指定了`anchor`，那么客户端指定的`anchor`在模拟交易时必须等于背书 peer 节点产生的`readset`。

然后，peer 节点内部提交交易提案（可能是`tx`）到它的逻辑部分来背书交易，称为背书逻辑。缺省时，一个 peer 节点的背书逻辑接受交易提案并简单签署。无论如何，背书逻辑可以执行任意功能，到，例如，与原有系统交互交易提案和`tx`作为输入来得知是否背书交易。

如果背书逻辑决定背书一个交易，它发送`<TRANSACTION-ENDORSED, tid, tran-proposal,epSig>`消息到提交客户端`(tx.clientID)`，其中：

* `tran-proposal := (epID,tid,chaincodeID,txContentBlob,readset,writeset)`，其中`txContentBlob`是链码/交易专用信息。目的是让`txContentBlob`用作`tx`的一些陈述 （例如, `txContentBlob=tx.txPayload`）。
* **epSig** 是背书peer节点的交易提案签名

否则，假使背书逻辑拒绝背书交易，背书者可以发送消息`(TRANSACTION-INVALID, tid, REJECTED)`到提交客户端。

注意背书者在这一步不能改变它的状态，在背书没有影响状态的情况下交易模拟产生状态更新。

### 2.3 提交客户端收集交易背书并通过排序服务广播它

提交客户端一直等待直到它在`(TRANSACTION-ENDORSED, tid, *, *)`上收集到“足够”的消息和签名来推断出交易提案已背书，这可能涉及一个或多个与背书者的往返。

“足够”的准确数字取决于链码背书策略。如果背书策略是安全的，交易已经背书；注意它还没提交。签署`TRANSACTION-ENDORSED`消息的收集从背书 peer 节点来，背书 peer 节点建立了交易是背书的称为背书并以背书为名称。

如果提交客户端没有设法为交易提案收集背书，则放弃这个交易，稍后再试。

对于一个具有有效背书的交易，我们现在开始使用排序服务。提交客户端使用`broadcast(blob)`调用排序服务，其中`blob=endorsement`。如果客户端没有能力直接调用排序服务，它可以通过它选择的 peer 节点代理广播。这样的 peer 节点必须被客户端信任不会从背书移除任何消息或其它可能被无效的交易。注意一点，无论如何，代理 peer 节点不可能制造有效背书。

### 2.4 排序服务向 peer 节点提交交易

当一个事件`(seqno, prevhash, blob)`发生并且一个 peer 节点已为所有序列号低于`seqno`的`blobs`更新状态，peer 节点执行如下流程：

* 它检查`blob.endorsement`是有效的，根据的是它引用的链码`(blob.tran-proposal.chaincodeID)`。
* 在典型情况下，它也验证了依赖`(blob.endorsement.tran-proposal.readset)`在期间没有被违反。在更复杂的用例中，背书中的交易提案（`tran-proposal`）域可能不同，在这种情况下，背书策略指定状态如何形成。

依赖的验证能以不同的方式实现，根据一致性属性或为状态更新选择的“孤立保证”。Serializability 是一个缺省的孤立保证，除非链码背书策略指定一个不同的。Serializability 能够通过在`readset`中的每个`key`关联的版本被提供，相当于`key`在状态中的版本，并拒绝不满足这个要求的交易。

* 如果所有这些检查通过，交易被视为有效或承诺。在这种情况下，peer 节点在`PeerLedger`用 1 标记交易，适用于`blob.endorsement.tran-proposal.writeset`区块链状态（如果交易提案是相同的，其它背书策略逻辑定义了函数处理`blob.endorsement`）。
* 如果`blob.endorsement`背书策略验证失败，交易无效，并且 peer 节点在`PeerLedger`的位掩码用 0 标记交易。重要的是要注意无效交易不会改变状态。

注意，这里有足够的让所有（正确）peer 节点在处理一个给定序列号的 deliver 事件（块）之后具有同样的状态。即，通过排序服务的保证，所有正确的 peer 节点会收到相同的`deliver(seqno, prevhash, blob)`事件序列。当背书策略的评估和`readset`中版本依赖的评估是确定的，所有正确的 peer 节点也会得出相同的结论，关于包含在`blob`中的交易是否有效。因此，所有 peer 节点提交和应用同样交易序列并用同样的方式更新它们的状态。

![图1.一种可能的交易流程说明（一般情况路径）](https://ws3.sinaimg.cn/large/006tNbRwgy1furswjf7ebj30wu0h5q3o.jpg)

**图1**.一种可能的交易流程说明（一般情况路径）

## 3. 背书策略（Eorsement policies）

### 3.1 背书策略规范（Endorsement policy specification）

**背书策略** 是背书一个交易的条件。区块链 peer 节点有一组预先确定的背书策略，它被安装特定链码的部署交易引用。背书策略能参数化，这些参数能被部署交易指定。

为了保证区块链和安全特性，背书策略组应该是一组验证过的策略，具有有限功能，为了保证有限的执行时间（终止），决定、性能和安全保证。

背书策略的动态添加（即，在链码部署时间由部署交易添加）是对背书评估时间限制（终止）、决定、性能和安全保证非常敏感的。因此，动态添加背书策略是不允许的，但将来能支持。

### 3.2 针对背书策略的交易评估

交易只有经过根据背书策略的背书才会宣布有效。对于链码的调用交易首先需要的到一个满足链码策略的背书，或不提交。这通过在提交客户端和背书peer节点之间的互动发生。

正式的背书策略是以背书为基础，以及潜在的进一步评估为真假状态。对于部署交易，获得背书的依据是系统系统范围策略（例如，来自系统链码）。

背书策略断言引用一定的变量。潜在可能引用的是：

1. 与链码有关的钥匙或身份（在链码元数据中能发现），例如，一组背书者；
2. 链码进一步的元数据；
3. `endorsement` 和 `endorsement.tran-proposal` 的元素;
4. 其他

上面的列表根据表现和复杂性排序，意思是说，它将会是相对简单的支持策略，只引用 node 节点的钥匙和身份。

**背书策略断言的评估必须被确定。** 背书应当被每个 peer 节点本地评估，这样这个 peer 节点就不需要和其它 peer 节点在这件事情上交互，但所有正确的 peer 节点都以相同的方式评估背书策略。

### 3.3 背书策略示例

断言可以包含逻辑表达式和评估真假。通常情况会对背书节点为链码发出的交易请求使用数字签名。

假定链码指定背书者集`E = {Alice, Bob, Charlie, Dave, Eve, Frank, George}`，一些例子策略如下：

* 一个有效签名来自全体`E`的成员的同样的交易提案。
* 一个有效签名来自`E`的任一单个成员。
* 从背书 peer 节点来的同一交易提案的有效签名条件是：`(Alice OR Bob) AND (any two of: Charlie, Dave, Eve, Frank, George)`
* 同一提案的有效签名为7名背书者的任意5名。（更常用的，链码`n>3f`背书者，`n` 名背书者有任意 `2f+1` 有效签名，或任意大于 `(n+f)/2` 背书者小组有效签名）
* 假定背书者有一个“股份”或“权重”的任务，像`{Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}`, 其中全部股份是 100：策略需要一组占大多数股份的有效签名（即，一组合并股份完全超过 50 ），像`{Alice, X}`，`X`只要不是`George`的任何人，或`{除去Alice以外的所有人}`，等等。
* 假定前面例子中的股权条件是静态的（固定在链码的元数据中）或动态的（例如，取决于链码的状态和在执行中修改）。
* 交易提案1的有效签名来自`(Alice OR Bob)` 和交易提案 2 有效签名来自（`Charlie, Dave, Eve, Frank, George`中的任何两个），其中交易提案 1 和交易提案 2 的不同只在它们的背书 peer 节点和状态更新。

如何使用这些策略取决于应用、失败或恶意背书者的恢复能力和各种其它特性。

