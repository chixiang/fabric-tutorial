# Hyperledger Fabric 架构说明

Hyperledger Fabric 带来了以下优势：

* **链码信任灵活性：** 架构将对链码（区块链应用程序）的信任假设与对排序的信任假设分离。换种说法，排序服务可以由一组节点（排序者）提供，并容忍其中一部分失败或作弊，每个链码可以有不同的背书者。
* **可扩展性：** 由于负责特定链码的背书者与排序者不重复，系统可以比由相同节点完成背书和排序这两个功能更加容易扩展。特别的，当不同的链码指定不同的背书者时，使不同背书者之间的链码分离，并且允许并行执行链码。此外，执行链码的资源消耗可能很大，于是让其与关键的排序服务分开单独部署。
* **保密性：** 架构使得对交易的内容和状态更新有保密要求的链码部署更加容易。
* **共识模块化：** 架构是模块化的，并且允许可插拔的实现共识机制（比如排序服务）。

---

**第一部分：Hyperledger Fabric v1 系统架构元素**

1. 系统架构
2. 交易背书的基本工作流
3. 背书策略

**第二部分：v1 后的架构元素**

4. 账本检查点（修订中）

## 1. 系统架构

区块链是一个由许多节点互相通信组成的分布式系统。区块链运行的程序叫做链码，用来保存状态和账本数据、执行交易。因为交易是在链码上调用的操作，因而链码是区块链结构的主要元素。交易必须被“背书”，而且只有背书过的交易才可以被提交或者是改变状态。有一个或多个用于管理功能和参数的特殊的链码，统称为系统链码。

### 1.1 交易

交易有两种类型：

* **部署交易（Deploy transactions）：** 创建新链码并以一个程序作为参数。当一个部署链码执行成功以后，链码就被安装在区块链上。
* **调用交易（Invoke transactions）：** 在之前部署的链码的上下文中执行操作。一笔调用交易指的是一个链码和他提供的若干功能中的其中一个。如果调用交易成功，链码执行了特定的函数，这个函数可能涉及修改相应的状态，然后返回结果。

后面会讲到，部署交易是一种特殊的调用交易，部署交易创建新的链码，相当于系统链码上的调用交易。

备注：本文档假定一笔交易或者创建新链码，或者调已经部署的链码提供的操作。本文档不包括：a) 查询（只读）交易的优化（已包含在 v1 版本），b) 跨链码交易的支持（v1 后版本特性）

### 1.2 区块链数据结构

#### 1.2.1 状态（status）

在建模中，区块链的最新状态为一个有版本的键值存储（KVS），名字作为键，值是任意二进制大对象（blobs）。这些键值对被运行在区块链上的链码（应用程序）通过`put`和`get`的 KVS 操作来操纵。状态被持久化存储并且状态的更新被记录为日志。请注意状态模型采用的是版本化的 KVS，具体实现可以使用 KVS 存储，也可以用关系数据库系统或其他的解决方案。

更正式地说，状态`s`被建模为一个映射的元素 `K -> (V X N)`，其中：

* `K`是键集合
* `V`是值集合
* `N`是一个版本号的无穷有序集合。内射函数`next: N -> N`取`N`中的一个元素并返回下一个版本号

`V`和`N`都包含一个特别的元素⊥（空类型），是`N`的最小元素。初始情况下所有的键都映射为(⊥, ⊥)，对于`s(k)=(v,ver)`我们通过`s(k).value`表示`v`，用`s(k).version`表示`ver`。

KVS 操作原型如下：

* `put(k,v)` for `k` ∈ `K` and `v` ∈ `V`, 状态`s`的新状态`s'`计算方法是：`s'(k)=(v,next(s(k).version))`。并且对所有的`k'!=k`，表达式`s'(k')=s(k')`都成立。
* `get(k)`返回`s(k)`

状态由对等点维护，而不是 order 节点和客户端。

**状态分区（State partitioning）：** KVS 中的键可以通过名称就能识别出它们属于哪个链码，所以只有特定链码的交易才能修改属于这个链码的键。原则上，任意的链码都能读取属于其他链码的键（机密链码的状态是不能明文读取的，参考第6部分）。修改两个或者多个链码状态的跨链交易，v1 的后续版本会支持。

#### 1.2.2 账本（ledger）

账本提供一份可验证历史信息，记录所有在系统操作中发生的成功的状态改变（有效交易）和未成功的对改变状态的尝试（无效交易）。

账本由排序服务构建为一个完整排序的交易（有效的和无效的）区块的哈希链。哈希链强制要求账本中的区块是完全排序的，并且每个区块内包含的交易是完全排序的。

账本存储在所有的对等点里，也可以选择保存在一部分排序者里。存在排序者节点内的账本我们叫排序者的账本（OedererLedger），而存在对等节点的账本我们叫对等点账本（PeerLedger）。对等点账本与排序者账本不同之处在于对等节点账本本地维护一个位掩码来区分有效交易和无效交易。

对等点可以删除对等点账本（v1 后续功能）。排序者维护排序者账本用于容错和（对等点账本的）可用性并可以随时决定删除对等点账本，前提是排序服务的属性保持不变。

账本允许对等点重播所有交易的历史来重构状态。因此，1.2.1 节谈到的状态是一个可选的数据结构。

### 1.3 节点（Node）

节点是区块链的通信实体。节点是一个逻辑的概念，不同类型的节点是可以运行在同一个物理服务器上的。重要的是节点是怎么被分组成“信任域（trust domains）”，怎么和控制它们的逻辑实体相关联。

有三种类型的节点：

* **客户端（client）或提交客户端（submitting-client）：** 一个客户端向背书者提交一笔实际发生的交易调用，并将交易提案广播给排序服务。
* **对等点（peer）：** 确认交易和维护账本的状态、保存账本的副本。除此之外，对等点有一个特别的背书者角色。
* **排序服务节点（Ordering-service-node ）或者排序者（orderer）：** 运行保证送达（deliver）的通信服务，如原子广播或完全排序广播。

接下来详细介绍各个节点类型。

#### 1.3.1 客户端（client）

一个客户端是一个代表最终用户的实体。它必须与一个对等点连接以实现同区块链的通信。客户端自己选择连接到任意的对等点。客户端创建然后调用交易。

客户端与对等节点和排序服务都通信。

#### 1.3.2 对等节点（peer）

一个对等点从排序服务接收以区块形式更新的有序状态，并且维护状态和账本。

对等节点可以额外承担一个特殊的背书节点（endorsing peer）的角色，或者称为背书者（endorser）。背书节点的特殊功能发生在特定的链码上，在一笔交易确认前为这笔交易背书。每一个链码可以指定一个关联一组背书节点的背书策略。这个策略定义了一个有效交易背书的充要条件（一般是一组背书者的签名）。对于安装新链码来部署交易的情况，（部署）背书策略被指定为系统链码的背书策略。

#### 1.3.3 排序服务节点（Orderers）

排序者构建排序服务，即一个提供保证送达（deliver）的通信结构。排序服务可以由不同的方法实现：可以是一个中心化的服务排序（例如在部署和测试时），也可以是针对不同的网络和节点故障模型的分布式协议。

排序服务为客户端和对等节点提供了一个共享的通信通道和一个交易信息的广播服务。客户端连接到通道（channel）上，然后可以在通道内向全部对等节点传送（deliver）广播信息。通道支持全部信息的原子传递，即消息通信是可靠（针对特定实现方法）的
完全排序（total-order）的。换种说法，通道输出相同的信息到所有连通的对等点，并且是按照相同的逻辑顺序输出。这个原子通信保证也称为完全顺序广播（total-order broadcast）、原子广播，或分布式系统上下文中的共识。发送的消息是将要包含在区块链状态中的候选交易。

**分区（ordering service channels）：** 排序服务可以支持多通道，这个通道就类似于发布/订阅消息系统里的主题（topic）。客户端可以连接到一个给定的通道发送消息和接收消息。通道可以被理解为分区，因为连接到一个通道的客户端不知道其他通道的存在，不过客户端可以连接到多个通道。即便Hyperledger Fabric 的一些排序服务支持多通道，为了简化表达，后续阐述将假定排序服务由一个单通道组成。

**排序服务API：** 对等点通过排序服务提供的接口连接到排序服务提供的通道上，排序服务API由两个基本操作组成（通常为异步事件）：

 * **broadcast(blob)**：广播，客户端调用这个操作在通道内广播任意信息`blob`。在拜占庭容错问题中向一个服务发送一个请求的时候也被称为`request(blob)`。
 * **deliver(seqno, prevhash, blob)**：传递，排序服务在对等节点调用这个操作传递包含指定的非负整数序列号（seqno）和前一个传递的 blob（prevhash）的哈希值的信息blob。换种说法，它是排序服务的一个输出事件。`deliver()`在发布-订阅系统中有时也被称为`notify()`，在拜占庭容错系统中被称为`commit()`。

**账本和区块编队：** 账本包括排序服务输出的全部数据。简言之，它是一个`deliver(seqno, prevhash, blob)`的序列，依据的是计算前面提到的`prevhash`来构建一条哈希链。

大多数时候，为了提高效率，排序服务会将交易`（blob）`打包，在一个`deliver`事件中输出多个区块，而不是每一笔交易单独输出。在这种情况下，排序服务必须对每一个区块里的交易强加一个确定的顺序。一个区块里的交易数量可以由一个排序服务的具体实现动态选择。

接下来，为了表达简便，我们基于每次`deliver`一个`blob`的假设定义了排序服务属性并且解释了交易背书的工作流。这个概念可以轻松扩展到区块，基于上面说的一个`block`里面的`blob`有确定的顺序，我们假定一个`block`的`deliver`事件对应一个`block`里的每一个`blob`的一系列`deliver`事件。

**排序服务属性**

排序服务（或原子广播通道）的保证规定了广播消息会发生什么和完成传递的消息之间存在什么关系。这些保证如下：

1. **安全性（一致性保证）：** 只要对等点连接上通道足够长的时间（他们可以断开连接或者宕机，但是会重启和重连），他们会看到唯一一串完成传递的`(seqno, prevhash, blob)`的信息。这意味着输出（`deliver()`事件）在所有对等点以相同的顺序发生，并且输出（`output`）依据序号为同一个序号携带相同的内容（`blob`和`prehash`）。注意这仅仅是一个逻辑顺序，而且一个对等点上的`delever(seqno, prevhash, blob)`不要求与在其他对等点上输出相同消息的`delever(seqno, prevhash, blob)`实时发生。换句话说，给定一个特定的`seqno`，没有两个对等点传递不同的`prevhash`或`blob`值。此外，除非某个客户端（对等点）实际调用了`broadcast(blob)`，没有`blob`值会被传送，每个广播过的`blob`只传递一次。此外，`deliver()`事件包含了前一个`deliver()`事件的加密哈希值（`prevhash`）。当排序服务实施原子广播保证时，`prevhash`是序列号为`seqno-1`的`deliver()`事件的哈希值。这就在不同的`deliver()`事件之间建立了一个哈希链，用于校验排序服务输出的正确性。第一个`deliver()`事件是一个特殊情况，`prevhash`有一个默认值。
2. **活跃度（Liveness）：传递保证（delivery guarantee）** 排序服务的活跃度保证是排序服务的实现指定的。精确的保证要依赖网络和节点故障模型。

总的来说，排序服务保证如下属性：

* **一致（Agreement）：** 正常对等节点的任意两个事件，`deliver(seqno, prevhash0, blob0)`和`deliver(seqno, prevhash1, blob1)`，如果有相同的`seqno`，则有`prevhash0==prevhash1`，`blob0==blob1`；
* **哈希链的完整性（Hashchain integrity）：** 正常对等节点的任意两个事件：`deliver(seqno-1, prevhash0, blob0)`和`deliver(seqno, prevhash, blob)`, `prevhash = HASH(seqno-1||prevhash0||blob0)`;
* **不跳跃（No skipping）：** 如果一个排序服务给一个正常节点`p`输出`deliver(seqno, prevhash, blob)`，如果`seqno>0`，则`p`一定已经传递了`deliver(seqno-1, prevhash0, blob0)`事件；
* **不创建（No creation）：** 一个正常节点的任意`deliver(seqno, prevhash, blob)`事件，前面一定有一个对等节点发送了`broadcast(blob)`事件；
* **不重复（No duplication，可选的）：** 对任意的两个事件`broadcast(blob)`和`broadcast(blob')`，当正常对等节点交付了两个事件，`deliver(seqno0, prevhash0, blob)`和`deliver(seqno1, prevhash1, blob')`，如果`blob==blob'`，则有`seqno0==seqno1`和`prevhash0==prevhash1`成立；
* **活跃度（Liveness）:** 如果一个正常对等节点产生了`broadcast(blob)`事件，则每个正常对等节点“最终”都会发出一个`deliver(*, *, blob)`事件，其中`*`代表任意值。

