# Hyperledger Fabric 架构说明

Hyperledger Fabric 带来了以下优势：

* **链码信任灵活性：** 架构将对链码（区块链应用程序）的信任假设与对排序的信任假设分离。换种说法，排序服务可以由一组节点（排序者）提供，并容忍其中一部分失败或作弊，每个链码可以有不同的背书者。
* **可扩展性：** 由于负责特定链码的背书者与排序者不重复，系统可以比由相同节点完成背书和排序这两个功能更加容易扩展。特别的，当不同的链码指定不同的背书者时，使不同背书者之间的链码分离，并且允许并行执行链码。此外，执行链码的资源消耗可能很大，于是让其与关键的排序服务分开单独部署。
* **保密性：** 架构使得对交易的内容和状态更新有保密要求的链码部署更加容易。
* **共识模块化：** 架构是模块化的，并且允许可插拔的实现共识机制（比如排序服务）。

---

**第一部分：Hyperledger Fabric v1 系统架构元素**

1. 系统架构
2. 交易背书的基本工作流
3. 背书策略

**第二部分：v1 后的架构元素**

4. 账本检查点（修订中）

## 1. 系统架构

区块链是一个由许多节点互相通信组成的分布式系统。区块链运行的程序叫做链码，用来保存状态和账本数据、执行交易。因为交易是在链码上调用的操作，因而链码是区块链结构的主要元素。交易必须被“背书”，而且只有背书过的交易才可以被提交或者是改变状态。有一个或多个用于管理功能和参数的特殊的链码，统称为系统链码。

### 1.1 交易

交易有两种类型：

* **部署交易（Deploy transactions）：** 创建新链码并以一个程序作为参数。当一个部署链码执行成功以后，链码就被安装在区块链上。
* **调用交易（Invoke transactions）：** 在之前部署的链码的上下文中执行操作。一笔调用交易指的是一个链码和他提供的若干功能中的其中一个。如果调用交易成功，链码执行了特定的函数，这个函数可能涉及修改相应的状态，然后返回结果。

后面会讲到，部署交易是一种特殊的调用交易，部署交易创建新的链码，相当于系统链码上的调用交易。

备注：本文档假定一笔交易或者创建新链码，或者调已经部署的链码提供的操作。本文档不包括：a) 查询（只读）交易的优化（已包含在 v1 版本），b) 跨链码交易的支持（v1 后版本特性）

### 1.2 区块链数据结构

#### 1.2.1 状态（status）

在建模中，区块链的最新状态为一个有版本的键值存储（KVS），名字作为键，值是任意二进制大对象（blobs）。这些键值对被运行在区块链上的链码（应用程序）通过`put`和`get`的 KVS 操作来操纵。状态被持久化存储并且状态的更新被记录为日志。请注意状态模型采用的是版本化的 KVS，具体实现可以使用 KVS 存储，也可以用关系数据库系统或其他的解决方案。

更正式地说，状态`s`被建模为一个映射的元素 `K -> (V X N)`，其中：

* `K`是键集合
* `V`是值集合
* `N`是一个版本号的无穷有序集合。内射函数`next: N -> N`取`N`中的一个元素并返回下一个版本号

`V`和`N`都包含一个特别的元素⊥（空类型），是`N`的最小元素。初始情况下所有的键都映射为(⊥, ⊥)，对于`s(k)=(v,ver)`我们通过`s(k).value`表示`v`，用`s(k).version`表示`ver`。

KVS 操作原型如下：

* `put(k,v)` for `k` ∈ `K` and `v` ∈ `V`, 状态`s`的新状态`s'`计算方法是：`s'(k)=(v,next(s(k).version))`。并且对所有的`k'!=k`，表达式`s'(k')=s(k')`都成立。
* `get(k)`返回`s(k)`

状态由对等点维护，而不是 order 节点和客户端。

**状态分区（State partitioning）：** KVS 中的键可以通过名称就能识别出它们属于哪个链码，所以只有特定链码的交易才能修改属于这个链码的键。原则上，任意的链码都能读取属于其他链码的键（机密链码的状态是不能明文读取的，参考第6部分）。修改两个或者多个链码状态的跨链交易，v1 的后续版本会支持。

#### 1.2.2 账本（ledger）

账本提供一份可验证历史信息，记录所有在系统操作中发生的成功的状态改变（有效交易）和未成功的对改变状态的尝试（无效交易）。

账本由排序服务构建为一个完整排序的交易（有效的和无效的）区块的哈希链。哈希链强制要求账本中的区块是完全排序的，并且每个区块内包含的交易是完全排序的。

账本存储在所有的对等点里，也可以选择保存在一部分排序者里。存在排序者节点内的账本我们叫排序者的账本（OedererLedger），而存在对等节点的账本我们叫对等点账本（PeerLedger）。对等点账本与排序者账本不同之处在于对等节点账本本地维护一个位掩码来区分有效交易和无效交易。